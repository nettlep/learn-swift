// ------------------------------------------------------------------------------------------------
// 本篇須知：
//
// * 陣列(Array)型別是一連串有序元素的集合
//
// * 能夠儲存在陣列型別的元素型別必須明確，要嘛是透過顯示地做型別註解指定型別，要嘛是透過型別自動推斷，
//   而且這些元素的型別不僅止於基礎型別
//
// * 陣列型別是型別安全的，而且它們包含的元素型別必須明確
//
// * 陣列型別是值型別，但 Swift 聰明地在真正需要的時候才做複製以提升效能
//
// * 在不可變陣列名稱中的不可變，其對象在於陣列本身以及它的內容物。這表示你不能新增/移除任何一個元素，也不能修改
//   陣列中的任何元素
// ------------------------------------------------------------------------------------------------

// 創建一個 String 型別的陣列
var someArray = Array<String>()

// 簡化的寫法，這是定義一個 String 陣列更常見的做法
var shorter: [String]

// 這是描述一個陣列的語法。因為所有的成員都是 String 型別，所以會創建一個 String 陣列。
//
// 假使不是所有的成員型別都相同(或被自動推斷為相同的型別)，那麼你會得到一個編譯錯誤
["Eggs", "Milk"]

// 讓我們創建一個裡頭有些東西的陣列。這裡將顯式地指定 String 型別：
var commonPets: [String] = ["Cats", "Dogs"]

// 我們也能讓 Swift 根據陣列在初始化時的成員型別來自動推斷陣列的型別
//
// 下面的例子就是一個 String 型別的陣列
var shoppingList = ["Eggs", "Milk"]

// ------------------------------------------------------------------------------------------------
// 存取以及修改一個陣列
//
// 我們能夠取得一個陣列中元素的個數
shoppingList.count

// 我們能夠檢查一個陣列是否為空
if !shoppingList.isEmpty { "it's not empty" }

// 我們能附加新的元素到陣列的尾部
shoppingList.append("Flour")
shoppingList.append("Baking Powder")
shoppingList.count

// 我們能增加相同型別的陣列到陣列的尾部(透過 + 運算子)
shoppingList += ["Chocolate Spread", "Cheese", "Butter"]
shoppingList.count

// 我們能藉由索引值來存取陣列中的特定元素
shoppingList[0]
shoppingList[1]

// 我們能修改存放在陣列中的元素
shoppingList[0] = "Six Eggs"

// 我們能使用範圍運算子來修改存放在陣列中的元素，這個操作修改了範圍運算子中指定範圍的所有元素。如果範圍運算子所
// 操作的範圍大小與原本陣列的大小不同，那麼這個陣列的大小將會被自動調整為操作範圍的大小
//
// 在此，我們將 3 個元素取代為 2 個，移除 1 個元素：
shoppingList[4...6] = ["Banannas", "Apples"]

// 或者也可以將 2 個元素取代為 3 個，插入一個新元素：
shoppingList[4..<6] = ["Limes", "Mint leaves", "Sugar"]

// 我們可以插入一個元素到指定的索引
shoppingList.insert("Maple Syrup", atIndex: 3)

// 我們可以移除最後一個元素。在此期間，可以透過將這個移除的元素儲存起來以保留這個元素。
let apples = shoppingList.removeLast()

// ------------------------------------------------------------------------------------------------
// 列舉
//
// 我們可以使用 for-in 的語法格式來迭代一個陣列
for item in shoppingList
{
	item
}

// 我們也可以使用 enumerate() 這個方法來回傳一個包含了每個元素的索引以及值的元組：
for (index, value) in enumerate(shoppingList)
{
	index
	value
}

// ------------------------------------------------------------------------------------------------
// 創建並初始化一個陣列
//
// 早先，我們看過如何宣告一個指定好型別的陣列。在這裡，我們會看到如何先宣告一個陣列，然後再將值塞給它以通過自動
// 推斷來決定它的型別：
var someInts = [Int]()

// 將數字 '3' 加到陣列裡頭
someInts.append(3)
someInts

// 我們可以將陣列的值指定為空陣列，但不要修改陣列的型別，因為 someInts 早已是一個 Int 型別的陣列
someInts = []

// 我們可以指定一個陣列的型別然後將它填滿特定的初始值
var threeDoubles = [Double](count: 3, repeatedValue: 3.3)

// 我們也可以使用陣列的初始化函式直接將它填滿特定的初始值，注意我們不需要指定陣列的型別，因為可以透過初始化元素
// 的型別來自動推斷：
var anotherThreeDoubles = Array(count: 3, repeatedValue: 2.5)

// 如果使用 let 宣告了一個常數陣列，這個陣列會被視為 "不可變陣列"
let immutableArray = ["a", "b"]

// 就不可變這個詞而言，你不能修改不可變陣列中的內含元素，也不能修改不可變陣列本身
//
// 我們不能更動不可變陣列中的元素內容：
//
// immutableArray[0] = "b"
//
// 也不能更改不可變陣列的大小或新增元素，這麼做只會招來編譯錯誤：
//
// immutableArray += "c"

// ------------------------------------------------------------------------------------------------
// 陣列是值型別
//
// 陣列是值型別，它只有在必要的時候才做複製，這個時機是陣列自己本身(非內容元素)做更動的時候
//
// 這邊有代表相同陣列的三個變數：
var a = [1, 2, 3]
var b = a
var c = a

// 然而，如果我們修改了其中一個陣列的內容(改變它)，那麼它會獨立為新的陣列實體：
a[0] = 42
b[0]
c[0]

// 改變了 a 陣列的值後，它會被複製到新的記憶體區塊，獨立擁有自己的實體。讓我們再次確認只有 b 與 c 是一樣的：
a
b
c

// 如果使用不同的方式去改變陣列(改變陣列的大小)，獨立為新陣列實體的概念也是相同的...
b.append(4)

// 現在，我們擁有了三個完全不同的陣列...
a
b
c

