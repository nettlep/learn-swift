// ------------------------------------------------------------------------------------------------
// 本篇須知：
//
// 類別與結構都能夠：
//
// * 定義用來儲存值的屬性
// * 定義提供功能的方法
// * 定義用來存取值的下標腳本
// * 定義將內容值初始化的建構器
// * 透過擴展來增加默認的功能
// * 符合某類別的協定以提供該類別的標準功能
//
// 類別才有的特性：
//
// * 繼承允許一個類別繼承另外一個類別的特性
// * 型別轉換讓你在運行時可以檢查以及解釋類別實體的型別
// * 解構子讓一個類別的實體釋放它被分配的資源
// * 參照計數允許對一個類別實體的多次參考
// ------------------------------------------------------------------------------------------------

// 首先，讓我們創建一個有幾個簡單屬性的基本結構
//
// 結構裡頭的屬性必須初始化，要不是宣告的時候有默認值，就是透過建構器(晚點談)。目前來說，我們只要確保它們都被默認值
// 初始化了即可
struct Resolution
{
	var width = 1280
	var height = 1024
}

// 同樣的，這兒是一個全被初始化了，擁有幾個屬性的基本類別。請留意第一個屬性是 Resolution 結構的實體
//
// 再來注意最後一個名為 'name' 的成員，我們沒有顯式地替它做初始化的原因，在於可選型別默認會被初始化為 nil
class VideoMode
{
	var resolution = Resolution()
	var interlaced = false
	var frameRate = 0.0
	var name: String?
}

// 這兒是一些我們結構與類別的實體：
var someResolution = Resolution()
var someVideoMode = VideoMode()

// ------------------------------------------------------------------------------------------------
// 存取屬性
//
// 我們可以使用點運算子 "." 來存取類別或結構的成員：
someResolution.width
someVideoMode.resolution.width

// 在 Objective-C 裡頭，如果一個物件包含了一個結構，這個子屬性(包含在這個物件的結構中的屬性)是不能直接做修改的。
// 這在 Swift 中不成問題，此操作不需要先初始化 Resolution 結構
someVideoMode.resolution.width = 2880
someVideoMode.resolution.height = 1800

// ------------------------------------------------------------------------------------------------
// 結構與列舉都是值型別
//
// 這表示當傳遞一個結構或列舉的實體進函式時(或將一個結構或列舉的實體賦值給另外一個變數)，事實上是對這個結構或列舉做
// 了值拷貝
//
// 讓我們創建兩個獨立的 Resolution 結構
let constantResolution = Resolution()
var variableResolution = constantResolution

// 我們可以修改 variableResolution 的屬性
variableResolution.width = 320
variableResolution.height = 200

// 然後發現用來賦值的變數 constantResolution 成員的屬性沒有變：
constantResolution

// 留意，因為結構以及列舉都是值型別，我們不能修改宣告為常數的實體內容：
//
// 下面這一行不能編譯:
//
// constantResolution.width = 320

// ------------------------------------------------------------------------------------------------
// 類別是參考型別：
//
// 這表示當傳遞一個物件的實體進函式(或將這個實體賦值給其他變數時)，新的變數儲存的指向原本物件的參照
//
// 讓我們創建一個物件並將它賦值給其他變數：
let constantVideoMode = VideoMode()
var variableVideoMode = constantVideoMode

// 如果我們修改了 variableVideoMode...
variableVideoMode.frameRate = 240

// ...我們可以發現另外一個實體也被修改了：(即使它被宣告為常數)
constantVideoMode.frameRate

// 此外，我們甚至可以修改 'constantVideoMode' 實體。能發生這種情況，是因為它是參考型別，而且修改屬性的動作並沒有
// 動到常數代表的參考本身(修改的是屬性，不是自己)
constantVideoMode.frameRate = 24

// 然而，我們不能修改這個變數實體
//
// 這一行將無法編譯：
//
// constantVideoMode = VideoMode

// ------------------------------------------------------------------------------------------------
// 結構型別裡頭針對個別成員的建構器
//
// 我們不需要為了設置屬性的值而特別撰寫一些初始化的程序。如果一個結構(非類別)沒有任何建構器，那麼 Swift 將會自動提供
// 我們 "針對個別成員的建構器"
//
// 針對個別成員的建構器而言，這兒有個再明顯不過的例子。它就是讓結構中的每一個屬性都包含了外部參數名稱的建構器。
let vga = Resolution(width: 640, height: 480)

// ------------------------------------------------------------------------------------------------
// 恆等運算子
//
// 因為類別是參考型別，我們使用恆等運算子 (===) 來檢查它們是否參考到同一個類別實體位址：
someVideoMode === variableVideoMode
constantVideoMode === variableVideoMode

// 恆等於跟等於是不一樣的：( === 不是 == )
//
// 下面這一行無法編譯，因為它使用了等於(==)運算子，但 Swift 的類別型別無法使用等於運算子的比較：
//
// constantVideoMode == variableVideoMode

